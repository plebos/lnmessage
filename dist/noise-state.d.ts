/// <reference types="node" />
import { Buffer } from 'buffer';
import type { NoiseStateOptions } from './types.js';
export declare class NoiseState {
    /**
     * The official protocol name for the Lightning variant of Noise. This
     * value is mixed into the iniitialiization function to start the
     * handshake.
     */
    protocolName: Buffer;
    /**
     * Appended to the hash of the protocolName during initialization.
     */
    prologue: Buffer;
    /**
     * Local secret is a 32-bit private key valid in elliptic curve
     * secp256k1. This value is unique to the node and should be
     * chosen with strong cryptographic randomness.
     */
    ls: Buffer;
    /**
     * Local compressed public key derviced from the local secret `ls`.
     * This value is stored as a 33-byte buffer.
     */
    lpk: Buffer;
    /**
     * Ephemeral secret is a 32-bit private key valid in elliptic curve
     * secp256k1. This value is generated by each node for each connection.
     * This value must be generated with strong cryptographic randomness.
     */
    es: Buffer;
    /**
     * Ephemeral compressed public key derived from the ephemeral secret
     * `es`. This value is stored as a 33-byte buffer.
     */
    epk: Buffer;
    /**
     * Remote compressed public key stored as a 33-byte buffer.
     */
    rpk: Buffer;
    /**
     * Remote party's ephemeral public key as a 33-byte buffer storing
     * the compressed public key. This value is extracted in act 2 where
     * it is sent during act 1 to the opposing side.
     */
    repk: Buffer;
    /**
     * Hanshake hash. This value is the accumulated hash of all handshake data that
     * has been sent and received during the handshake process.
     */
    h: Buffer;
    /**
     * Chaining key. This value is the accumulated hash of all previous ECDH outputs.
     * At the end of the handshake, `ck` is used to dervice the encryption keys
     * for messages.
     */
    ck: Buffer;
    /**
     * The key used is the receiving key used to decrypt messages sent by the
     * other side. It is generated in Act3.
     */
    rk: Buffer;
    /**
     * The key used by the sender to encrypt messages to the receiver. This value
     * is generated in Act3.
     */
    sk: Buffer;
    /**
     * Nonce incremented when sending messages. Initialized to zero in Act3.
     */
    sn: Buffer;
    /**
     * Nonce incremented when receiving messages. Initialized to zero in Act3.
     */
    rn: Buffer;
    /**
    * Chaining key for sending. Initialized to ck in Act 3.
    */
    sck: Buffer;
    /**
    * Chaining key for receiving. Initialized to ck in Act 3.
    */
    rck: Buffer;
    /**
     * Intermediate key 1. Used to encrypt or decrypt the zero-length AEAD
     * payload in the corresponding initiator or receiver act.
     */
    tempK1: Buffer;
    /**
     * Intermediate key 2. Used to encrypt or decrypt the zero-length AEAD
     * payload in the corresponding initiator or receiver act.
     */
    tempK2: Buffer;
    /**
     * Intermediate key 3. Used to encrypt or decrypt the zero-length AEAD
     * payload in the corresponding initiator or receiver act.
     */
    tempK3: Buffer;
    /**
     * State machine for perforing noise-protocol handshake, message
     * encryption and decryption, and key rotation.
     */
    constructor({ ls, es }: NoiseStateOptions);
    /**
     * Initiator Act1 is the starting point for the authenticated key exchange
     * handshake. The initiator attempts to satisfy an implicit challenge by the
     * responder: knowledge of the static public key of the responder. It also
     * transmits the initiators ephemeral key.
     * @param rpk remote public key
     * @return Buffer that is 50 bytes
     */
    initiatorAct1(rpk: Buffer): Buffer;
    /**
     * Initiator Act2 handles the response generated by the receiver's
     * Act1, a 50-byte message. The responder's ephemeral key is extacted
     * from the message during this phase.
     *
     * @param m 50-byte message from responder's act1
     */
    initiatorAct2(m: Buffer): void;
    /**
     * Initiator Act3 is the final phase in the authenticated
     * key agreement. This act is executed only if act 2
     * was successful. The initiator transports its static public key
     * to the responder.
     */
    initiatorAct3(): Buffer;
    /**
     * Receiver Act1 extracts the initiators ephemeral key. It also
     * validates that the initiator knows the receivers public key.
     * @param m 50-byte message sent by the initiator
     */
    receiveAct1(m: Buffer): void;
    /**
     * Receiver Act2 takes place only if Act1 was successful.
     * This act sends responder's ephermeral key to the initiator.
     */
    recieveAct2(): Buffer;
    /**
     * Receiver Act3 is the final phase in the authenticated key
     * agreement. This act is executed only if act 2 was successful.
     * The receiver extracts the public key of the initiator.
     * @param m 66-byte message
     */
    receiveAct3(m: Buffer): void;
    /**
     * Sends an encrypted message using the shared sending key and nonce.
     * The nonce is rotated once the message is sent. The sending key is
     * rotated every 1000 messages.
     * @param m
     */
    encryptMessage(m: Buffer): Buffer;
    /**
     * Decrypts the length of the message using the receiving key and nonce.
     * The receiving key is rotated every 1000 messages.
     */
    decryptLength(lc: Buffer): number;
    /**
     * Decrypts the message using the receiving key and nonce. The receiving
     * key is rotated every 1000 messages.
     */
    decryptMessage(c: Buffer): Buffer;
    /**
     * Initializes the noise state prior to Act1.
     */
    private _initialize;
    private _incrementSendingNonce;
    private _incrementRecievingNonce;
    private _rotateSendingKeys;
    private _rotateRecievingKeys;
}
